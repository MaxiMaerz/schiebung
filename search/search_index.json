{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Schiebung","text":"<p>Full Documenation</p> <p>Schiebung is german for \"shift\" as in \"shift the frame\" or \"shift the coordinate system\".</p> <p>Schiebung offers a library which stores transformations (or isometries) between frames. These isometries are between two frames. It is assumed that all frames are either connected or root/leaf nodes. The resulting structure is used to produce any transformation between frames by chaining their transformations. Additionally each pair of frames keeps a history of transformations, this allows a user to ask for transformations in the past, if the exact time cannot be found the transformation between the two best matching times will be interpolated (lerp/slerp).</p> <p>The original concept and a far better explanation can be found here: ROS tf It also draws inspiration from the rust implementation for ROS 1 rosrust_tf</p> <p>/    Your browser does not support the video tag. </p> <p>In the video you can see a very basic example utilizing the TransformBuffer in combination with the rerun visualizer: We publish the bodies once (Sun, Earth and Moon) and just update the transforms in their respective frames:</p> <ul> <li>earth circles around the sun</li> <li>moon circles around the earth</li> <li>The distance between the moon and sun is calculated by a simple frame lookup (Moon -&gt; Sun)</li> </ul> <p>This allows the user to make a complexe (in this context) problem complelty trivial. As long as the TransformBuffer is updated all derived transformations can be calculated at all times (using lerp/slerp). It also makes it possible to calculate transformations without knowing anything of the actual transformation chain as long as the end and start of the chain are known.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>TF2 is available in ROS2, the implementation is super sturdy and battle tested. However some project might not want the huge ROS dependencies overhead. While it is possible to use TF2 without ROS, it lacks some features we need.</p> <p>It is most likely that our implementation also:</p> <ul> <li>is faster than TF2 (40-80ns per lookup)</li> <li>is memory safe (typical RUST argument)</li> </ul> <p>However TF2 is a great tool and will most likely be the best choice for ROS 2 based projects. This project is very new and Bugs will most likely be found.</p>"},{"location":"#design-goals","title":"Design goals","text":"<ul> <li>As fast as possible: Sub-microsecond lookups and updates</li> <li>ROS (2) agnostic: While it is possible to use alongside TF2, the target is a system outside the ROS ecosystem.</li> <li>All features are optional: Depending on user requirements dependencies can be pulled in on required feature set</li> <li>Minimal, scalable and fast client server structure: We use cap'n proto + zenoh for communication.</li> <li>Easy to use: We ship a urdf loader and provide a simple Rerun API.</li> </ul>"},{"location":"#status","title":"Status","text":"<p>This library is still under development and the API is not considered stable yet and might change.</p> <ul> <li>The core library is fairly well tested, the python bindings work.</li> <li>The rerun implementation is a rather shallow wrapper around the core and should be \"ok\"</li> <li>For the server and the full implementation (server + rerun) there is quite some work left.</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Check the other pages for examples and use cases:</p> <ul> <li>Core: Contains a rust and python implementation for the Buffer only, no dependencies to rerun or zenoh.</li> <li>Comms: Contains a rust and python implementation for the client server structure using cap'n proto and zenoh.</li> <li>Visualizer: Contains a rust and python implementation for the visualizer using rerun.</li> </ul>"},{"location":"schiebung-comms/","title":"Schiebung Comms","text":"<p>Client-Server communication for Schiebung transforms using Zenoh and capn'proto. Currently no Python bindings are provided; however, it is possible to connect against the server with any zenoh client. If we see the need for users to run the server in a python environment, we can create the bindings.</p>"},{"location":"schiebung-comms/#overview","title":"Overview","text":"<p>The comms package provides a client-server architecture for sharing transform data between processes. It uses Zenoh for low-latency inter-process communication. We use a simple capn'proto schema to serialize the data (currently none of the fancy cap'n proto RPC Features are used).</p>"},{"location":"schiebung-comms/#architecture","title":"Architecture","text":"<pre><code>graph LR\n    Client_1[\"Client&lt;br/&gt;- Query&lt;br/&gt;- Publish\"]\n    Client_N[\"Client&lt;br/&gt;- Query&lt;br/&gt;- Publish\"]\n    Server[\"Server&lt;br/&gt;BufferTree\"]\n\n    Client_1 &lt;--&gt;|Zenoh| Server\n    Client_N &lt;--&gt;|Zenoh| Server</code></pre>"},{"location":"schiebung-comms/#transform-update-flow","title":"Transform Update Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Zenoh\n    participant Server\n\n    Client-&gt;&gt;Zenoh: Publish Transform\n    Zenoh-&gt;&gt;Server: Forward Transform\n    Server-&gt;&gt;Server: Update BufferTree\n    Note over Client,Server: Fire-and-forget (no acknowledgment)</code></pre>"},{"location":"schiebung-comms/#transform-request-flow","title":"Transform Request Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Zenoh\n    participant Server\n\n    Client-&gt;&gt;Zenoh: Query Transform (from, to)\n    Zenoh-&gt;&gt;Server: Forward Query\n    Server-&gt;&gt;Server: Lookup in BufferTree\n    Server--&gt;&gt;Zenoh: Transform Result\n    Zenoh--&gt;&gt;Client: Return Transform</code></pre>"},{"location":"schiebung-comms/#usage","title":"Usage","text":""},{"location":"schiebung-comms/#client-example","title":"Client Example","text":"<pre><code>use comms::TransformClient;\n\n#[tokio::main]\nasync fn main() {\n    let client = TransformClient::new().await.unwrap();\n\n    // Publish a transform\n    client.publish_transform(\"base\", \"sensor\", transform).await;\n\n    // Query a transform\n    let result = client.request_transform(\"base\", \"sensor\").await;\n}\n</code></pre>"},{"location":"schiebung-core/python/","title":"Python Bindings for Schiebung","text":"<p>This crate contains the Python bindings for the Schiebung library. It provides a Python interface to the core functionality of the Schiebung library.</p> <p>The bindings are generated using pyo3 and maturin. The binaries are published to PyPI.</p>"},{"location":"schiebung-core/python/#installation","title":"Installation","text":"<p>The bindings can be installed using pip or uv:</p> <pre><code>pip install schiebung\n</code></pre> <p>For a quick demo:</p> <pre><code>uv run --with schiebung,ipython ipython\n</code></pre>"},{"location":"schiebung-core/python/#usage","title":"Usage","text":"<pre><code>from schiebung import BufferTree, StampedIsometry, TransformType\n\nbuffer = BufferTree()\n# Timestamps are in nanoseconds (1_000_000_000 = 1 second)\nbuffer.update(\"base_link\", \"target_link\", StampedIsometry(translation=(1, 0, 0), rotation=(0, 0, 0, 1), stamp=1_000_000_000), TransformType.Static)\nresult = buffer.lookup_transform(\"base_link\", \"target_link\", 1_000_000_000)\n\nprint(f\"Translation: {result.translation()}\")\nprint(f\"Rotation: {result.rotation()}\")\nprint(f\"Euler angles: {result.euler_angles()}\")\n</code></pre>"},{"location":"schiebung-core/python/#dynamic-transforms-with-interpolation","title":"Dynamic Transforms with Interpolation","text":"<pre><code>from schiebung import BufferTree, StampedIsometry, TransformType\nimport time\n\nbuffer = BufferTree()\n\n# Add transforms at different times (timestamps in nanoseconds)\nfor i in range(5):\n    t_ns = i * 100_000_000  # 100ms intervals in nanoseconds\n    transform = StampedIsometry(\n        translation=[i * 0.1, 0.0, 0.0],\n        rotation=[0.0, 0.0, 0.0, 1.0],\n        stamp=t_ns\n    )\n    buffer.update(\"base\", \"end\", transform, TransformType.Dynamic)\n\n# Interpolate at intermediate time (250ms in nanoseconds)\nresult = buffer.lookup_transform(\"base\", \"end\", 250_000_000)\nprint(f\"Interpolated transform: {result}\")\n</code></pre>"},{"location":"schiebung-core/python/#visualize-the-buffer","title":"Visualize the buffer","text":"<p>The visualize function returns a graphviz dot string. This can used with any graphviz viewer.</p> <pre><code>from schiebung import BufferTree, StampedIsometry, TransformType\n\nbuffer = BufferTree()\n# Timestamp in nanoseconds (1_000_000_000 = 1 second)\niso = StampedIsometry([0,0,1], [0,0,0,1], 1_000_000_000)\nbuffer.update(\"a\", \"b\", iso, TransformType.Dynamic)\nbuffer.update(\"a\", \"c\", iso, TransformType.Dynamic)\nbuffer.update(\"b\", \"b_1\", iso, TransformType.Dynamic)\nbuffer.update(\"c\", \"c_1\", iso, TransformType.Dynamic)\nprint(buffer.visualize())\n</code></pre>"},{"location":"schiebung-core/rust/","title":"Core Library for Schiebung","text":"<p>This crate contains the pure Rust core functionality of the Schiebung library. It provides a buffer for storing and retrieving transforms without any Python dependencies.</p>"},{"location":"schiebung-core/rust/#installation","title":"Installation","text":"<pre><code>git clone git@github.com:MaxiMaerz/schiebung.git\ncd schiebung\ncargo build\n</code></pre>"},{"location":"schiebung-core/rust/#usage","title":"Usage","text":"<p>This will create a local buffer, this buffer will NOT fill itself!</p> <pre><code>use schiebung_core::BufferTree;\n\nlet buffer = BufferTree::new();\nlet stamped_isometry = StampedIsometry {\n    isometry: Isometry::from_parts(\n        Translation3::new(\n            1.0,\n            2.0,\n            3.0,\n        ),\n        UnitQuaternion::new_normalize(Quaternion::new(\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n        )),\n    ),\n    stamp: 1_000_000_000  // nanoseconds (1 second)\n};\nbuffer.update(\"base_link\", \"target_link\", stamped_isometry, TransformType::Static);\n\nlet transform = buffer.lookup_transform(\"base_link\", \"target_link\", 1.0);\n</code></pre>"},{"location":"schiebung-core/rust/#how-it-works","title":"How it works","text":""},{"location":"schiebung-core/rust/#update-the-buffer","title":"Update the Buffer","text":"<p>Each isometry sent to the buffer is, after validation, stored in an Directed Acyclic Graph (DAG). We use petgraph for the Graph implementation. We extend it with a Hashmap to lookup the human readable names of the nodes (Which is currently the biggest bottleneck).Currently we check if the graph becomes cyclic and if so, we reject the update.</p> <p>If the update is the first update a TransformHistory is created and stored in the graph. We also check for cyclicality here, store all ancestors for this node and update the ancestors of the children of this node. This means the first update is rather expensive. All subsequent updates are just appended to existing TransformHistory.</p> <p>We differentiate between static and dynamic transforms. Static transforms are stored in the graph as a single transform, dynamic transforms are stored in a TransformHistory.</p> <p>Currently the size of the history is limited to a reasonable amount of 120 seconds, this can be changed in the config file. There is NO safeguard against pushing to many updates to the buffer, e.g. if the time does not advance fast enough. This will lead to a large memory footprint. Reasonable frequencies of 1-1000 Hz have been tested more might be possible.</p>"},{"location":"schiebung-core/rust/#lookup-a-transform","title":"Lookup a Transform","text":"<p>After the buffer is filled, any transform can be requested, we will walk from the \"from\" frame to the \"to\" frame and chain the isometries resulting in the connection isometry from the \"from\" frame to the \"to\" frame. We support two lookup types:</p> <ol> <li>lookup_latest_transform: This will return the latest stored transform for any TransformHistory in the chain and timestamp it to the latest timestamp in the chain.</li> <li>lookup_transform: Here a stamp must be provided and the transform will be interpolated based on the TransformHistory in the chain. nalgebra's lerp_slerp is used for interpolation.</li> </ol> <p>lookup_latest_transform will work if a path \"from\" to \"to\" exists in the graph.</p> <p>lookup_transform will fail if:</p> <ul> <li>A path \"from\" to \"to\" does not exist in the graph</li> <li>If any link's oldest transform is newer than the requested timestamp</li> <li>If any link's newest transform is older than the requested timestamp</li> </ul>"},{"location":"schiebung-core/rust/#observer","title":"Observer","text":"<p>It is possible to register an observer to the buffer, on registration the buffer sends the latest transform for each link in the graph to the observer. Afterwards the observer is notified whenever a transform is updated or added to the buffer.</p>"},{"location":"schiebung-core/rust/#visualizer","title":"Visualizer","text":"<p>The visualize methods converts the graph into a graphviz dot string, if graphviz is installed we can save the graph as a pdf.</p>"},{"location":"schiebung-core/rust/#performance","title":"Performance","text":"<p>The performance can be tested via:</p> <pre><code>cd core/schiebung-core-rs\ncargo bench --bench buffer_benchmark\n</code></pre>"},{"location":"schiebung-core/rust/#summary","title":"Summary","text":"<p>The performance was measured on a AMD Ryzen 7 PRO 8840HS under reasonable system load.</p> <p>A matrix multiplication takes about 12ns with nalgebra, our call takes around 40 ns. An interpolated lookup takes around 70 ns.</p> <p>The path length should scale linearly with the number of nodes. Which makes sense since we multiply more matrices. Runtime is not affected by the size of the transform history.</p> <p>After some benchmarking, we found that the our bottleneck is the hash map lookup from frame names to nodes. We could provide a deeper API to avoid this, but the performance is already good enough for most use cases.</p> <p>A selected but not exhaustive set of benchmarks is shown in the table below:</p>"},{"location":"schiebung-core/rust/#core-operations","title":"Core Operations","text":"Operation Time (ns) Description Update (new edge, static) 498 Creating a new transform link Update (existing edge, dynamic) 56 Appending to existing history Lookup (simple, interpolated) 63 Interpolated lookup, 2 frames Lookup (latest) 43 Latest transform, 2 frames Path finding (2 nodes) 49 Simple path traversal Path finding (100 nodes) 2,375 Deep tree traversal Lookup (100 edge chain) 2,751 Transform chain through 100 edges"},{"location":"schiebung-core/rust/#transformhistory-scaling","title":"TransformHistory Scaling","text":"<p>Update performance remains constant regardless of history size:</p> History Size Update Time (ns) Notes 100 55.5 1,000 54.9 10,000 52.8 60,000 53.0 1 min @ 1kHz 120,000 53.4 2 min @ 1kHz <p>Lookup performance shows minimal degradation with history size:</p> History Size Interpolated Lookup (ns) Latest Lookup (ns) 100 64 44 1,000 67 44 10,000 75 45 60,000 77 49 120,000 79 44"},{"location":"schiebung-visualizer/python/","title":"Schiebung Rerun Integration","text":"<p>Python bindings for schiebung with integrated Rerun visualization.</p> <p>While the Rust implementation exposes the recording stream directly when registering the observer, we do not have the same luxury in Python. We use reruns amazing feature to merge recordings. This means that by having the same application and recording ID the compiled part of the 'RerunBufferTree' can be accessed and visualized together with your Python code. This even works across Processes.</p>"},{"location":"schiebung-visualizer/python/#installation","title":"Installation","text":"<pre><code>cd schiebung-rerun-py\nmaturin develop\n</code></pre>"},{"location":"schiebung-visualizer/python/#usage","title":"Usage","text":"<pre><code>from schiebung_rerun import RerunBufferTree, StampedIsometry, TransformType\n\n# Create a RerunBufferTree with Rerun logging\ntree = RerunBufferTree(\"schiebung\", \"session_001\", \"stable_time\", True)\n\n# Access the buffer to add transforms (they will be logged to Rerun automatically)\n# Timestamp in nanoseconds (1_000_000_000 = 1 second)\nt = StampedIsometry([1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], 1_000_000_000)\ntree.buffer.update(\"world\", \"robot\", t, TransformType.Static)\n\n# Query transforms via the buffer\nresult = tree.buffer.lookup_latest_transform(\"world\", \"robot\")\nprint(result.translation())  # [1.0, 0.0, 0.0]\n</code></pre>"},{"location":"schiebung-visualizer/rust/","title":"Schiebung Rerun (Rust)","text":"<p>Rust library for visualizing Schiebung transforms using Rerun.</p>"},{"location":"schiebung-visualizer/rust/#overview","title":"Overview","text":"<p>This crate provides a <code>RerunObserver</code> that can be attached to a <code>BufferTree</code> to automatically log all transform updates to Rerun for visualization.</p> <p>Currently the logging of Transforms is rather simple:</p> <ul> <li>from is the parent frame</li> <li>to is the child frame</li> <li>All is under a flat namespace /transforms/{from}-&gt;{to}</li> <li>We use the provided timeline to set the timestamp for each transform</li> </ul>"},{"location":"schiebung-visualizer/rust/#example","title":"Example","text":"<pre><code>use schiebung::BufferTree;\nuse schiebung_rerun::RerunObserver;\nuse rerun::RecordingStream;\n\nfn main() {\n    // Create a Rerun recording\n    let rec = rerun::RecordingStreamBuilder::new(\"my_app\")\n        .spawn()\n        .unwrap();\n\n    // Create observer and attach to buffer\n    let observer = RerunObserver::new(rec, true, \"stable_time\".to_string());\n    let mut buffer = BufferTree::new();\n    buffer.register_observer(Box::new(observer));\n\n    // All updates will now be logged to Rerun\n    buffer.update(\"world\", \"robot\", transform, TransformType::Static);\n}\n</code></pre>"},{"location":"schiebung-visualizer/rust/#rerunbuffertree","title":"RerunBufferTree","text":"<p>We also provide a <code>RerunBufferTree</code> which is a drop-in replacement for <code>BufferTree</code>. This is most likely of little use for a implementation in Rust, but it is useful for Python bindings where we can not just mix and match.</p>"}]}